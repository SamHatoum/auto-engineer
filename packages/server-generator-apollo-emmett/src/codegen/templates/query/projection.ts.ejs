<%
const origin = slice.server?.data?.[0]?.origin;
const isSingleton = origin?.singleton === true;
const idField = origin?.idField;
const isCompositeKey = Array.isArray(idField);
const compositeKeyFields = isCompositeKey ? idField : [];
%>import {
inMemorySingleStreamProjection,
type ReadEvent,
type InMemoryReadEventMetadata,
} from '@event-driven-io/emmett';
import type { <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> } from './state';<%
if (eventImportGroups.length > 0) {
    for (const group of eventImportGroups) {
%>
import type { <%= group.eventTypes.join(', ') %> } from '<%= group.importPath %>';
<%
    }
}

// Collect enums used in state fields
const stateEnums = [];
const targetName = slice.server?.data?.[0]?.target?.name;
if (targetName && messages) {
    const targetDef = messages.find(m => m.name === targetName);
    if (targetDef?.fields) {
        for (const field of targetDef.fields) {
            const fieldType = (field.type || '').replace(/\s*\|\s*null/g, '').trim();
            if (fieldType.includes('|') && (fieldType.includes('"') || fieldType.includes("'"))) {
                const enumName = toTsFieldType(field.type);
                if (enumName && enumName !== 'String' && !stateEnums.includes(enumName)) {
                    stateEnums.push(enumName);
                }
            }
        }
    }
}

if (stateEnums.length > 0) {
%>
import { <%= stateEnums.join(', ') %> } from '../../../shared';
<%
} -%>
<% if (isSingleton) { %>
// SINGLETON AGGREGATION PATTERN
// This projection maintains a single document that aggregates data from multiple entities.
// Use internal state to track individual entity information for accurate calculations.
interface Internal<%= pascalCase(targetName || 'State') %> extends <%= pascalCase(targetName || 'State') %> {
  _entities?: Record<string, { status?: string; [key: string]: unknown }>;
}
<% } %>
type AllEvents = <%= allEventTypes %>;

export const projection = inMemorySingleStreamProjection<
<%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %>,
AllEvents
>({
collectionName: '<%= pascalCase(slice.server?.data?.[0]?.origin?.name || "unknown-collection") %>',
canHandle: [<%- events.map(e => `'${e.type}'`).join(', ') %>],
getDocumentId: (<%- isSingleton ? '_event' : 'event' %>) => <%
if (isSingleton) {
%>'<%= toKebabCase(slice.server?.data?.[0]?.target?.name || 'singleton') %>'<%
} else if (isCompositeKey) {
    const template = compositeKeyFields.map((field, index) =>
        index === 0 ? `\${event.data.${field}}` : `-\${event.data.${field}}`
    ).join('');
%>`<%= template %>`<%
} else {
    const singleIdField = typeof idField === 'string' ? idField : 'id';
%>event.data.<%= singleIdField %><%
}
%>,
evolve: (
document: <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null,
event: ReadEvent<AllEvents, InMemoryReadEventMetadata>
): <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null => {
switch (event.type) {
<% for (const event of events) {
    const targetName = slice.server?.data?.[0]?.target?.name;
    const queryGwt = slice.type === 'query'
            ? queryGwtMapping.find(gwt => {
                    const inGiven = gwt.given && gwt.given.some(g => g.eventRef === event.type);
                    const inWhen = gwt.when.some(g => g.eventRef === event.type);
                    return inGiven || inWhen;
            })
            : undefined;
    const example = slice.type === 'query'
            ? queryGwt?.then.find(t => t.stateRef === targetName)?.exampleData
            : gwtMapping[event.type]?.[0]?.then?.[0]?.exampleData;
    const targetDef = messages.find(m => m.name === slice.server?.data?.[0]?.target?.name);
    const targetFields = Object.fromEntries((targetDef?.fields ?? []).map(f => [f.name, f]));
    let usedFields = [];
    let isRemovalEvent = false;
    if (typeof example !== 'undefined') {
        if (example && Object.keys(example).length > 0) {
            usedFields = Object.keys(example);
        } else {
            isRemovalEvent = true;
        }
    } else if (targetFields) {
        usedFields = Object.keys(targetFields);
    }
    const eventNameSuggestsRemoval = event.type.toLowerCase().includes('remove') ||
            event.type.toLowerCase().includes('delete');
%>
case '<%= event.type %>': {
/**
* ## IMPLEMENTATION INSTRUCTIONS ##
<% if (isSingleton) { -%>
    * **SINGLETON AGGREGATION PATTERN**
    *
    * This projection maintains ONE document aggregating data from MANY entities.
    *
    * CRITICAL: Use internal state to track individual entity information:
    *
    * 1. Access current state:
    *    const current: Internal<%= pascalCase(targetName || 'State') %> = document ?? { ...initialState, _entities: {} };
    *
    * 2. Track entity changes:
    *    // a) Extract the unique identifier that distinguishes this entity
    *    //    Examine event.data to find the ID field (often 'id' or '<entity>Id')
    *    const entityId = event.data.[ENTITY_ID_FIELD];
    *
    *    // b) Store/update entity state with relevant properties from event.data
    *    //    Include only fields needed for aggregation calculations
    *    current._entities[entityId] = { [field]: value, ... };
    *
    * 3. Calculate aggregates from entity states:
    *    const counts = Object.values(current._entities).reduce((acc, entity) => {
    *      acc[entity.status] = (acc[entity.status] || 0) + 1;
    *      return acc;
    *    }, {});
    *
    * 4. Return with internal state:
    *    return { ...publicFields, _entities: current._entities } as Internal<%= pascalCase(targetName || 'State') %>;
<% } else if (isCompositeKey) { -%>
    * **COMPOSITE KEY PROJECTION**
    *
    * This projection uses a composite key: <%= compositeKeyFields.join(' + ') %>
    * Document ID format: `${event.data.<%= compositeKeyFields[0] %>}-${event.data.<%= compositeKeyFields.slice(1).join('}}-${event.data.') %>}`
    *
    * CRITICAL: You MUST include ALL key fields in every return statement:
    * <%- compositeKeyFields.map(f => `- ${f}: event.data.${f}`).join('\n    * ') %>
    *
    * Missing even one key field will cause the projection to fail.
    * Key fields typically map directly from event data (no transformation needed).
    *
    * Example implementation:
    *    return {
    *      <%- compositeKeyFields.map(f => `${f}: event.data.${f},`).join('\n    *      ') %>
    *      // ... other fields
    *    };
<% } else if (isRemovalEvent || eventNameSuggestsRemoval) { -%>
    * This event might indicate removal of a <%= targetName || 'document' %>.
    *
    * - If the intent is to **remove the document**, return `null`.
    * - If the intent is to **soft delete**, consider adding a `status` field (e.g., `status: 'removed'`).
    * - Ensure consumers of this projection (e.g., UI) handle the chosen approach appropriately.
<% } else { -%>
    * Implement how this event updates the projection.
    *
    * **IMPORTANT - Internal State Pattern:**
    * If you need to track state beyond the public <%= pascalCase(targetName || 'State') %> type (e.g., to calculate
    * aggregations, track previous values, etc.), follow this pattern:
    *
    * 1. Define an extended interface BEFORE the projection:
    *    interface Internal<%= pascalCase(targetName || 'State') %> extends <%= pascalCase(targetName || 'State') %> {
    *      internalField: SomeType;
    *    }
    *
    * 2. Cast document parameter to extended type:
    *    const current: Internal<%= pascalCase(targetName || 'State') %> = document ?? { ...defaults };
    *
    * 3. Cast return values to extended type:
    *    return { ...allFields, internalField } as Internal<%= pascalCase(targetName || 'State') %>;
    *
    * This keeps internal state separate from the public GraphQL schema.
<% } -%>
*/
<% if (isRemovalEvent) { -%>
    return null;
<% } else if (usedFields.length === 0) { -%>
    // No fields specified - returning null
    return null;
<% } else { -%>
    return {
    <% for (let i = 0; i < usedFields.length; i++) {
        const field = usedFields[i];
        const isLast = i === usedFields.length - 1;
        const def = (targetFields ?? {})[field];
        const type = def?.type ?? 'string';

        let placeholder = 'undefined';
        const isNullable = type.includes('| null') || type.includes('|null');
        const baseType = isNullable ? type.replace(/\s*\|\s*null/g, '').trim() : type;

        if (baseType === 'string' || baseType === 'ID') {
            placeholder = isNullable ? "/* TODO: map from event.data */ null" : "/* TODO: map from event.data */ ''";
        } else if (baseType === 'number') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ 0';
        } else if (baseType === 'boolean') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ false';
        } else if (baseType === 'Date') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ new Date()';
        } else if (baseType.startsWith('Array<')) {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ []';
        } else if (baseType.includes('|') && (baseType.includes('"') || baseType.includes("'"))) {
            const enumName = toTsFieldType(type);
            const firstValue = baseType.match(/['"]([^'"]+)['"]/)?.[1] ?? '';
            const enumConstant = firstValue ? firstValue.toUpperCase().replace(/[^A-Z0-9]/g, '_') : '';
            if (enumName && enumName !== 'String') {
                placeholder = `${enumName}.${enumConstant} /* TODO: verify this enum constant is correct */`;
            } else {
                placeholder = `/* TODO: use enum constant from types.ts */ '${firstValue}'`;
            }
        } else {
            placeholder = '/* TODO: map from event.data */ undefined as any';
        }
    %>        <%= field %>: <%- placeholder %><%= isLast ? '' : ',' %>
    <% } -%>
    };
<% } -%>
}
<% } -%>
default:
return document;
}
},
});

export default projection;