import {
inMemorySingleStreamProjection,
type ReadEvent,
type InMemoryReadEventMetadata,
} from '@event-driven-io/emmett';
import type { <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> } from './state';<%
if (eventImportGroups.length > 0) {
    for (const group of eventImportGroups) {
%>
import type { <%= group.eventTypes.join(', ') %> } from '<%= group.importPath %>';
<%
    }
} -%>

type AllEvents = <%= allEventTypes %>;

export const projection = inMemorySingleStreamProjection<
<%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %>,
AllEvents
>({
collectionName: '<%= pascalCase(slice.server?.data?.[0]?.origin?.name || "unknown-collection") %>',
canHandle: [<%- events.map(e => `'${e.type}'`).join(', ') %>],
getDocumentId: (event) => <%
const idField = slice.server?.data?.[0]?.origin?.idField ?? 'id';
// Check if idField contains hyphen-separated composite keys
if (idField.includes('-')) {
    const parts = idField.split('-');
    const template = parts.map((part, index) =>
        index === 0 ? `\${event.data.${part}}` : `-\${event.data.${part}}`
    ).join('');
%>`<%= template %>`<%
} else {
%>event.data.<%= idField %><%
}
%>,
evolve: (
document: <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null,
event: ReadEvent<AllEvents, InMemoryReadEventMetadata>
): <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null => {
switch (event.type) {
<% for (const event of events) {
    const targetName = slice.server?.data?.[0]?.target?.name;
    const queryGwt = slice.type === 'query'
            ? queryGwtMapping.find(gwt => {
                    const inGiven = gwt.given && gwt.given.some(g => g.eventRef === event.type);
                    const inWhen = gwt.when.some(g => g.eventRef === event.type);
                    return inGiven || inWhen;
            })
            : undefined;
    const example = slice.type === 'query'
            ? queryGwt?.then.find(t => t.stateRef === targetName)?.exampleData
            : gwtMapping[event.type]?.[0]?.then?.[0]?.exampleData;
    const targetDef = messages.find(m => m.name === slice.server?.data?.[0]?.target?.name);
    const targetFields = Object.fromEntries((targetDef?.fields ?? []).map(f => [f.name, f]));
    let usedFields = [];
    let isRemovalEvent = false;
    if (typeof example !== 'undefined') {
        if (example && Object.keys(example).length > 0) {
            usedFields = Object.keys(example);
        } else {
            isRemovalEvent = true;
        }
    } else if (targetFields) {
        usedFields = Object.keys(targetFields);
    }
    const eventNameSuggestsRemoval = event.type.toLowerCase().includes('remove') ||
            event.type.toLowerCase().includes('delete');
%>
case '<%= event.type %>': {
/**
* ## IMPLEMENTATION INSTRUCTIONS ##
<% if (isRemovalEvent || eventNameSuggestsRemoval) { -%>
    * This event might indicate removal of a <%= targetName || 'document' %>.
    *
    * - If the intent is to **remove the document**, return `null`.
    * - If the intent is to **soft delete**, consider adding a `status` field (e.g., `status: 'removed'`).
    * - Ensure consumers of this projection (e.g., UI) handle the chosen approach appropriately.
<% } else { -%>
    * This event adds or updates the document.
    * Implement the correct fields as needed for your read model.
<% } -%>
*/
<% if (isRemovalEvent) { -%>
    return null;
<% } else if (usedFields.length === 0) { -%>
    // No fields specified - returning null
    return null;
<% } else { -%>
    return {
    <% for (let i = 0; i < usedFields.length; i++) {
        const field = usedFields[i];
        const isLast = i === usedFields.length - 1;
        const def = (targetFields ?? {})[field];
        const type = def?.type ?? 'string';

        let placeholder = 'undefined';
        if (type === 'string' || type === 'ID') {
            placeholder = "/* TODO: map from event.data */ ''";
        } else if (type === 'number') {
            placeholder = '/* TODO: map from event.data */ 0';
        } else if (type === 'boolean') {
            placeholder = '/* TODO: map from event.data */ false';
        } else if (type === 'Date') {
            placeholder = '/* TODO: map from event.data */ new Date()';
        } else if (type.startsWith('Array<')) {
            placeholder = '/* TODO: map from event.data */ []';
        } else {
            placeholder = '/* TODO: map from event.data */ undefined as any';
        }
    %>        <%= field %>: <%- placeholder %><%= isLast ? '' : ',' %>
    <% } -%>
    };
<% } -%>
}
<% } -%>
default:
return document;
}
},
});

export default projection;