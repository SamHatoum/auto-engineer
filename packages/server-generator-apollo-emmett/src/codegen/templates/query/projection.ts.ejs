import {
inMemorySingleStreamProjection,
type ReadEvent,
type InMemoryReadEventMetadata,
} from '@event-driven-io/emmett';
import type { <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> } from './state';<%
if (eventImportGroups.length > 0) {
    for (const group of eventImportGroups) {
%>
import type { <%= group.eventTypes.join(', ') %> } from '<%= group.importPath %>';
<%
    }
}

// Collect enums used in state fields
const stateEnums = [];
const targetName = slice.server?.data?.[0]?.target?.name;
if (targetName && messages) {
    const targetDef = messages.find(m => m.name === targetName);
    if (targetDef?.fields) {
        for (const field of targetDef.fields) {
            const fieldType = (field.type || '').replace(/\s*\|\s*null/g, '').trim();
            if (fieldType.includes('|') && (fieldType.includes('"') || fieldType.includes("'"))) {
                const enumName = toTsFieldType(field.type);
                if (enumName && enumName !== 'String' && !stateEnums.includes(enumName)) {
                    stateEnums.push(enumName);
                }
            }
        }
    }
}

if (stateEnums.length > 0) {
%>
import { <%= stateEnums.join(', ') %> } from '../../../shared';
<%
} -%>

type AllEvents = <%= allEventTypes %>;

export const projection = inMemorySingleStreamProjection<
<%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %>,
AllEvents
>({
collectionName: '<%= pascalCase(slice.server?.data?.[0]?.origin?.name || "unknown-collection") %>',
canHandle: [<%- events.map(e => `'${e.type}'`).join(', ') %>],
getDocumentId: (event) => <%
const idField = slice.server?.data?.[0]?.origin?.idField ?? 'id';
// Check if idField contains hyphen-separated composite keys
if (idField.includes('-')) {
    const parts = idField.split('-');
    const template = parts.map((part, index) =>
        index === 0 ? `\${event.data.${part}}` : `-\${event.data.${part}}`
    ).join('');
%>`<%= template %>`<%
} else {
%>event.data.<%= idField %><%
}
%>,
evolve: (
document: <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null,
event: ReadEvent<AllEvents, InMemoryReadEventMetadata>
): <%= pascalCase(slice.server?.data?.[0]?.target?.name || 'UnknownState') %> | null => {
switch (event.type) {
<% for (const event of events) {
    const targetName = slice.server?.data?.[0]?.target?.name;
    const queryGwt = slice.type === 'query'
            ? queryGwtMapping.find(gwt => {
                    const inGiven = gwt.given && gwt.given.some(g => g.eventRef === event.type);
                    const inWhen = gwt.when.some(g => g.eventRef === event.type);
                    return inGiven || inWhen;
            })
            : undefined;
    const example = slice.type === 'query'
            ? queryGwt?.then.find(t => t.stateRef === targetName)?.exampleData
            : gwtMapping[event.type]?.[0]?.then?.[0]?.exampleData;
    const targetDef = messages.find(m => m.name === slice.server?.data?.[0]?.target?.name);
    const targetFields = Object.fromEntries((targetDef?.fields ?? []).map(f => [f.name, f]));
    let usedFields = [];
    let isRemovalEvent = false;
    if (typeof example !== 'undefined') {
        if (example && Object.keys(example).length > 0) {
            usedFields = Object.keys(example);
        } else {
            isRemovalEvent = true;
        }
    } else if (targetFields) {
        usedFields = Object.keys(targetFields);
    }
    const eventNameSuggestsRemoval = event.type.toLowerCase().includes('remove') ||
            event.type.toLowerCase().includes('delete');
%>
case '<%= event.type %>': {
/**
* ## IMPLEMENTATION INSTRUCTIONS ##
<% if (isRemovalEvent || eventNameSuggestsRemoval) { -%>
    * This event might indicate removal of a <%= targetName || 'document' %>.
    *
    * - If the intent is to **remove the document**, return `null`.
    * - If the intent is to **soft delete**, consider adding a `status` field (e.g., `status: 'removed'`).
    * - Ensure consumers of this projection (e.g., UI) handle the chosen approach appropriately.
<% } else { -%>
    * Implement how this event updates the projection.
    *
    * **IMPORTANT - Internal State Pattern:**
    * If you need to track state beyond the public <%= pascalCase(targetName || 'State') %> type (e.g., to calculate
    * aggregations, track previous values, etc.), follow this pattern:
    *
    * 1. Define an extended interface BEFORE the projection:
    *    interface Internal<%= pascalCase(targetName || 'State') %> extends <%= pascalCase(targetName || 'State') %> {
    *      internalField: SomeType;
    *    }
    *
    * 2. Cast document parameter to extended type:
    *    const current: Internal<%= pascalCase(targetName || 'State') %> = (document as Internal<%= pascalCase(targetName || 'State') %>) || { ...defaults };
    *
    * 3. Cast return values to extended type:
    *    return { ...allFields, internalField } as Internal<%= pascalCase(targetName || 'State') %>;
    *
    * This keeps internal state separate from the public GraphQL schema.
<% } -%>
*/
<% if (isRemovalEvent) { -%>
    return null;
<% } else if (usedFields.length === 0) { -%>
    // No fields specified - returning null
    return null;
<% } else { -%>
    return {
    <% for (let i = 0; i < usedFields.length; i++) {
        const field = usedFields[i];
        const isLast = i === usedFields.length - 1;
        const def = (targetFields ?? {})[field];
        const type = def?.type ?? 'string';

        let placeholder = 'undefined';
        const isNullable = type.includes('| null') || type.includes('|null');
        const baseType = isNullable ? type.replace(/\s*\|\s*null/g, '').trim() : type;

        if (baseType === 'string' || baseType === 'ID') {
            placeholder = isNullable ? "/* TODO: map from event.data */ null" : "/* TODO: map from event.data */ ''";
        } else if (baseType === 'number') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ 0';
        } else if (baseType === 'boolean') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ false';
        } else if (baseType === 'Date') {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ new Date()';
        } else if (baseType.startsWith('Array<')) {
            placeholder = isNullable ? '/* TODO: map from event.data */ null' : '/* TODO: map from event.data */ []';
        } else if (baseType.includes('|') && (baseType.includes('"') || baseType.includes("'"))) {
            const enumName = toTsFieldType(type);
            const firstValue = baseType.match(/['"]([^'"]+)['"]/)?.[1] ?? '';
            const enumConstant = firstValue ? firstValue.toUpperCase().replace(/[^A-Z0-9]/g, '_') : '';
            if (enumName && enumName !== 'String') {
                placeholder = `${enumName}.${enumConstant} /* TODO: verify this enum constant is correct */`;
            } else {
                placeholder = `/* TODO: use enum constant from types.ts */ '${firstValue}'`;
            }
        } else {
            placeholder = '/* TODO: map from event.data */ undefined as any';
        }
    %>        <%= field %>: <%- placeholder %><%= isLast ? '' : ',' %>
    <% } -%>
    };
<% } -%>
}
<% } -%>
default:
return document;
}
},
});

export default projection;