<%
const target = slice?.server?.data?.[0]?.target;
const projection = slice?.server?.data?.[0]?.origin;
const isSingleton = projection?.singleton === true;
const queryName = parsedRequest?.queryName ?? camelCase(sliceName);
const viewType = target?.name ? pascalCase(target.name) : 'UnknownView';
const projectionType = projection?.name ? pascalCase(projection.name) : 'UnknownProjection';
const message = messages?.find(m => m.name === viewType);
const resolverClassName = `${pascalCase(slice.name)}QueryResolver`;
const usesID = parsedRequest?.args?.some(arg => graphqlType(arg.tsType) === 'ID');

const messageFields = message?.fields ?? [];
const usesDate = messageFields.some(f => fieldUsesDate(f.type)) ||
        (parsedRequest?.args ?? []).some(a => fieldUsesDate(a.tsType));
const usesJSON = messageFields.some(f => fieldUsesJSON(f.type)) ||
        (parsedRequest?.args ?? []).some(a => fieldUsesJSON(a.tsType));
const usesFloat = messageFields.some(f => fieldUsesFloat(f.type)) ||
        (parsedRequest?.args ?? []).some(a => fieldUsesFloat(a.tsType));

const enumList = collectEnumNames([...messageFields, ...(parsedRequest?.args ?? [])]);

const embeddedTypes = [];
for (const field of messageFields) {
    const tsType = field.type ?? 'string';
    if (isInlineObjectArray(tsType) || isInlineObject(tsType)) {
        embeddedTypes.push({
            typeName: `${viewType}${pascalCase(field.name)}`,
            tsType,
        });
    }
}
const hasArgs = parsedRequest?.args?.length > 0;
%>
import { Query, Resolver<% if (hasArgs) { %>, Arg<% } %>, Ctx, ObjectType, Field<% if (usesID) { %>, ID<% } %><% if (usesFloat) { %>, Float<% } %><% if (usesDate) { %>, GraphQLISODateTime<% } %> } from 'type-graphql';
<% if (usesJSON) { %>import { GraphQLJSON } from 'graphql-type-json';
<% } %>import { type GraphQLContext<% if (!isSingleton) { %>, ReadModel<% } %><% if (enumList.length > 0) { %>, <%= enumList.join(', ') %><% } %> } from '../../../shared';

<%
        for (const { typeName, tsType } of embeddedTypes) {
    const inner = tsType.trim().startsWith('Array<')
            ? tsType.trim().replace(/^Array<\{/, '{').replace(/}>$/, '}')
            : tsType.trim().replace(/\[\]$/, '');
    const match = inner.match(/^\{([\s\S]*)\}$/);
    const body = match ? match[1] : '';
    const rawFields = body.split(/[,;]\s*/).filter(Boolean);
    const parsedFields = rawFields.map(f => {
        const parts = f.split(':');
        const name = parts[0]?.trim();
        const type = parts.slice(1).join(':').trim();
        if (!name || !type) return null;
        return { name, tsType: type, gqlType: graphqlType(type), nullable: isNullable(type) };
    }).filter(Boolean);
%>
@ObjectType()
export class <%= typeName %> {
<% for (const f of parsedFields) { %>
    @Field(() => <%= f.gqlType %><%= f.nullable ? ', { nullable: true }' : '' %>)
    <%= f.name %><%= f.nullable ? '?' : '!' %>: <%= toTsFieldType(f.tsType) %>;
<% } %>
}
<% } %>

@ObjectType()
export class <%= viewType %> {
<% if (messageFields.length) {
        for (const field of messageFields) {
    const tsType = field.type ?? 'string';
    const gqlType = graphqlType(tsType);
    const typeName = `${viewType}${pascalCase(field.name)}`;
%>
<% if (isInlineObjectArray(tsType)) { %>
    @Field(() => [<%= typeName %>])
    <%= field.name %>!: <%= typeName %>[];
<% } else if (isInlineObject(tsType)) { %>
    @Field(() => <%= typeName %>)
    <%= field.name %>!: <%= typeName %>;
<% } else { %>
    @Field(() => <%= gqlType %><%= isNullable(tsType) ? ', { nullable: true }' : '' %>)
    <%= field.name %><%= isNullable(tsType) ? '?' : '!' %>: <%= toTsFieldType(tsType) %>;
<% } } %>

  // IMPORTANT: Index signature required for ReadModel<T extends Record<string, unknown>> compatibility
  [key: string]: unknown;
<% } else { %>
  // IMPORTANT: Index signature required for ReadModel<T extends Record<string, unknown>> compatibility
  [key: string]: unknown;
<% } %>
}

@Resolver()
export class <%= resolverClassName %> {
<% if (isSingleton) { %>
@Query(() => <%= viewType %>)
async <%= queryName %>(
@Ctx() ctx: GraphQLContext<% if (parsedRequest?.args?.length) { %>,
<%   for (let i = 0; i < parsedRequest.args.length; i++) {
    const arg = parsedRequest.args[i];
    const gqlType = graphqlType(arg.tsType);
    const tsType = arg.tsType === 'ID' ? 'string' : arg.tsType;
%>    @Arg('<%= arg.name %>', () => <%= gqlType %>, { nullable: true }) <%= arg.name %>?: <%= tsType %><%= i < parsedRequest.args.length - 1 ? ',' : '' %>
<%   } } %>
): Promise<<%= viewType %>> {
  const result = await ctx.database.collection<<%= viewType %>>('<%= projectionType %>').findOne();

  if (!result) {
    return {
<% for (let i = 0; i < messageFields.length; i++) {
    const field = messageFields[i];
    const tsType = field.type ?? 'string';
    const baseType = tsType.replace(/\s*\|\s*null/g, '').trim();
    let defaultValue = '0';

    if (baseType === 'string' || baseType === 'ID') {
      defaultValue = "''";
    } else if (baseType === 'number') {
      defaultValue = '0';
    } else if (baseType === 'boolean') {
      defaultValue = 'false';
    } else if (baseType === 'Date') {
      defaultValue = 'new Date()';
    } else if (baseType.startsWith('Array<')) {
      defaultValue = '[]';
    } else if (baseType.includes('|') && (baseType.includes('"') || baseType.includes("'"))) {
      const firstValue = baseType.match(/['"]([^'"]+)['"]/)?.[1] ?? '';
      defaultValue = `'${firstValue}'`;
    }
%>      <%= field.name %>: <%= defaultValue %>,
<% } %>    };
  }

  return result;
}
<% } else { %>
@Query(() => [<%= viewType %>])
async <%= queryName %>(
@Ctx() ctx: GraphQLContext<% if (parsedRequest?.args?.length) { %>,
<%   for (let i = 0; i < parsedRequest.args.length; i++) {
    const arg = parsedRequest.args[i];
    const gqlType = graphqlType(arg.tsType);
    const tsType = arg.tsType === 'ID' ? 'string' : arg.tsType;
%>    @Arg('<%= arg.name %>', () => <%= gqlType %>, { nullable: true }) <%= arg.name %>?: <%= tsType %><%= i < parsedRequest.args.length - 1 ? ',' : '' %>
<%   } } %>
): Promise<<%= viewType %>[]> {
const model = new ReadModel<<%= viewType %>>(ctx.database, '<%= projectionType %>');

// ## IMPLEMENTATION INSTRUCTIONS ##
// You can query the projection using the ReadModel API:
// - model.getAll() — fetch all documents
// - model.getById(id) — fetch a single document by ID (default key: 'id')
// - model.find(filterFn) — filter documents using a predicate
// - model.first(filterFn) — fetch the first document matching a predicate
//
// Example below uses \`.find()\` to filter
// change the logic for the query as needed to meet the requirements for the current slice.

return model.find((<%= hasArgs ? 'item' : '_item' %>) => {
<% if (parsedRequest?.args?.length) {
        for (const arg of parsedRequest.args) { %>
    if (<%= arg.name %> !== undefined && item.<%= arg.name %> !== <%= arg.name %>) return false;
<% } } %>
return true;
});
}
<% } %>
}